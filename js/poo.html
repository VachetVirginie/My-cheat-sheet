<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>POO</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
        <div>
                <ul>
                    <li><a class="active" href="../index.html">Home</a></li>
                    <li><a href="js.html">Javascript</a></li>
                        
                       
                </ul>
        </div>
<br>
    <h1>Javascript Object Oriented Programming</h1>
<h4>Source free code camp course.</h4>
<h2>Basic JavaScript: Build JavaScript Objects</h2>
<p>You may have heard the term object before.</p>
<p>Objects are similar to arrays, except that instead of using indexes to access and modify their data, you access the data in objects through what are called properties.</p>
<p>Objects are useful for storing data in a structured way, and can represent real world objects, like a cat.</p>
<p>Here's a sample cat object:</p>
<pre><code class="` language-`">var cat = {
  "name": "Whiskers",
  "legs": 4,
  "tails": 1,
  "enemies": ["Water", "Dogs"]
};
</code></pre>
<p>`
In this example, all the properties are stored as strings, such as - "name", "legs", and "tails". However, you can also use numbers as properties. You can even omit the quotes for single-word string properties, as follows:</p>
<pre><code class="` language-`">var anotherObject = {
  make: "Ford",
  5: "five",
  "model": "focus"
};
</code></pre>
<p>`
However, if your object has any non-string properties, JavaScript will automatically typecast them as strings.</p>
<hr />
<h2>Accessing Object Properties with Dot Notation</h2>
<p>There are two ways to access the properties of an object: dot notation (.) and bracket notation ([]), similar to an array.</p>
<p>Dot notation is what you use when you know the name of the property you're trying to access ahead of time.</p>
<p>Here is a sample of using dot notation (.) to read an object's property:</p>
<pre><code class="` language-`">var myObj = {
  prop1: "val1",
  prop2: "val2"
};
var prop1val = myObj.prop1; // val1
var prop2val = myObj.prop2; // val2
</code></pre>
<h2>`</h2>
<h2>Accessing Object Properties with Bracket Notation</h2>
<p>The second way to access the properties of an object is bracket notation ([]). If the property of the object you are trying to access has a space in its name, you will need to use bracket notation.</p>
<p>However, you can still use bracket notation on object properties without spaces.</p>
<p>Here is a sample of using bracket notation to read an object's property:</p>
<pre><code class="` language-`">var myObj = {
  "Space Name": "Kirk",
  "More Space": "Spock",
  "NoSpace": "USS Enterprise"
};
myObj["Space Name"]; // Kirk
myObj['More Space']; // Spock
myObj["NoSpace"]; // USS Enterprise
</code></pre>
<p>`
Note that property names with spaces in them must be in quotes (single or double).</p>
<hr />
<h2>Accessing Object Properties with Variables</h2>
<p>Another use of bracket notation on objects is to access a property which is stored as the value of a variable. This can be very useful for iterating through an object's properties or when accessing a lookup table.</p>
<p>Here is an example of using a variable to access a property:</p>
<pre><code class="` language-`">var dogs = {
  Fido: "Mutt", Hunter: "Doberman", Snoopie: "Beagle"
};
var myDog = "Hunter";
var myBreed = dogs[myDog];
console.log(myBreed); // "Doberman"
</code></pre>
<p>`
Another way you can use this concept is when the property's name is collected dynamically during the program execution, as follows:</p>
<pre><code class="` language-`">var someObj = {
  propName: "John"
};
function propPrefix(str) {
  var s = "prop";
  return s + str;
}
var someProp = propPrefix("Name"); // someProp now holds the value 'propName'
console.log(someObj[someProp]); // "John"
</code></pre>
<p>`
Note that we do not use quotes around the variable name when using it to access the property because we are using the value of the variable, not the name.</p>
<hr />
<h2>Updating Object Properties</h2>
<p>After you've created a JavaScript object, you can update its properties at any time just like you would update any other variable. You can use either dot or bracket notation to update.</p>
<p>For example, let's look at ourDog:</p>
<pre><code class="` language-`">var ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
</code></pre>
<p>`
Since he's a particularly happy dog, let's change his name to "Happy Camper". Here's how we update his object's name property:</p>
<pre><code class="` language-`">ourDog.name = "Happy Camper"; or

ourDog["name"] = "Happy Camper";
</code></pre>
<p>`
Now when we evaluate ourDog.name, instead of getting "Camper", we'll get his new name, "Happy Camper".</p>
<hr />
<h2>Add New Properties to a JavaScript Object</h2>
<p>You can add new properties to existing JavaScript objects the same way you would modify them.</p>
<p>Here's how we would add a "bark" property to ourDog:</p>
<pre><code class="` language-`">ourDog.bark = "bow-wow";
</code></pre>
<p>`
or</p>
<pre><code class="` language-`">ourDog["bark"] = "bow-wow";
</code></pre>
<p>`
Now when we evaluate ourDog.bark, we'll get his bark, "bow-wow".</p>
<hr />
<h2>Delete Properties from a JavaScript Object</h2>
<p>We can also delete properties from objects like this:</p>
<pre><code class="` language-`">delete ourDog.bark;
</code></pre>
<p>`</p>
<hr />
<h2>Using Objects for Lookups</h2>
<p>Objects can be thought of as a key/value storage, like a dictionary. If you have tabular data, you can use an object to "lookup" values rather than a switch statement or an if/else chain. This is most useful when you know that your input data is limited to a certain range.</p>
<p>Here is an example of a simple reverse alphabet lookup:</p>
<pre><code class="` language-`">var alpha = {
  1:"Z",
  2:"Y",
  3:"X",
  4:"W",
  ...
  24:"C",
  25:"B",
  26:"A"
};
alpha[2]; // "Y"
alpha[24]; // "C"

var value = 2;
alpha[value]; // "Y"
</code></pre>
<p>`</p>
<hr />
<h2>Create a Method on an Object</h2>
<p>Objects can have a special type of property, called a method.</p>
<p>Methods are properties that are functions. This adds different behavior to an object. Here is the duck example with a method:</p>
<pre><code class="` language-`">let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {return "The name of this duck is " + duck.name + ".";}
};
duck.sayName();
// Returns "The name of this duck is Aflac."
</code></pre>
<p>`
The example adds the sayName method, which is a function that returns a sentence giving the name of the duck.</p>
<p>Notice that the method accessed the name property in the return statement using duck.name. The next challenge will cover another way to do this.</p>
<hr />
<h2>Make Code More Reusable with the this Keyword</h2>
<p>The last challenge introduced a method to the duck object. It used duck.name dot notation to access the value for the name property within the return statement:</p>
<p>sayName: function() {return "The name of this duck is " + duck.name + ".";}</p>
<p>While this is a valid way to access the object's property, there is a pitfall here. If the variable name changes, any code referencing the original name would need to be updated as well. In a short object definition, it isn't a problem, but if an object has many references to its properties there is a greater chance for error.</p>
<p>A way to avoid these issues is with the this keyword:</p>
<pre><code class="` language-`">let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {return "The name of this duck is " + this.name + ".";}
};
this is a deep topic, and the above example is only one way to use it. In the current context, this refers to the object that the method is associated with: duck.
</code></pre>
<p>`
If the object's name is changed to mallard, it is not necessary to find all the references to duck in the code. It makes the code reusable and easier to read.</p>
<hr />
<h2>Define a Constructor Function</h2>
<p>Constructors are functions that create new objects. They define properties and behaviors that will belong to the new object. Think of them as a blueprint for the creation of new objects.</p>
<p>Here is an example of a constructor:</p>
<pre><code class="` language-`">function Bird() {
  this.name = "Albert";
  this.color = "blue";
  this.numLegs = 2;
}
</code></pre>
<p>`</p>
<p>This constructor defines a Bird object with properties name, color, and numLegs set to Albert, blue, and 2, respectively.</p>
<p>Constructors follow a few conventions:</p>
<p>Constructors are defined with a capitalized name to distinguish them from other functions that are not constructors.</p>
<p>Constructors use the keyword this to set properties of the object they will create. Inside the constructor, this refers to the new object it will create.</p>
<p>Constructors define properties and behaviors instead of returning a value as other functions might.</p>
<hr />
<h2>Use a Constructor to Create Objects</h2>
<p>Here's the Bird constructor from the previous challenge:</p>
<pre><code class="` language-`">function Bird() {
  this.name = "Albert";
  this.color = "blue";
  this.numLegs = 2;
  // "this" inside the constructor always refers to the object being created
}

let blueBird = new Bird();
</code></pre>
<p>`
Notice that the new operator is used when calling a constructor. This tells JavaScript to create a new instance of Bird called blueBird. Without the new operator, this inside the constructor would not point to the newly created object, giving unexpected results.</p>
<p>Now blueBird has all the properties defined inside the Bird constructor:</p>
<pre><code class="` language-`">blueBird.name; // =&gt; Albert
blueBird.color; // =&gt; blue
blueBird.numLegs; // =&gt; 2
</code></pre>
<p>`
Just like any other object, its properties can be accessed and modified:</p>
<pre><code class="` language-`">blueBird.name = 'Elvira';
blueBird.name; // =&gt; Elvira
</code></pre>
<p>`</p>
<hr />
<h2>Extend Constructors to Receive Arguments</h2>
<p>The Bird and Dog constructors from last challenge worked well. However, notice that all Birds that are created with the Bird constructor are automatically named Albert, are blue in color, and have two legs. What if you want birds with different values for name and color? It's possible to change the properties of each bird manually but that would be a lot of work:</p>
<pre><code class="` language-`">let swan = new Bird();
swan.name = "Carlos";
swan.color = "white";
</code></pre>
<p>`
Suppose you were writing a program to keep track of hundreds or even thousands of different birds in an aviary. It would take a lot of time to create all the birds, then change the properties to different values for every one.</p>
<p>To more easily create different Bird objects, you can design your Bird constructor to accept parameters:</p>
<pre><code class="` language-`">function Bird(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}
</code></pre>
<p>`
Then pass in the values as arguments to define each unique bird into the Bird constructor:</p>
<pre><code class="` language-`">let cardinal = new Bird("Bruce", "red");
</code></pre>
<p>`
This gives a new instance of Bird with name and color properties set to Bruce and red, respectively. The numLegs property is still set to 2.</p>
<p>The cardinal has these properties:</p>
<pre><code class="` language-`">cardinal.name // =&gt; Bruce
cardinal.color // =&gt; red
cardinal.numLegs // =&gt; 2
</code></pre>
<p>`
The constructor is more flexible. It's now possible to define the properties for each Bird at the time it is created, which is one way that JavaScript constructors are so useful. They group objects together based on shared characteristics and behavior and define a blueprint that automates their creation.</p>
<hr />
<h2>Verify an Object's Constructor with instanceof</h2>
<p>Anytime a constructor function creates a new object, that object is said to be an instance of its constructor. JavaScript gives a convenient way to verify this with the instanceof operator. instanceof allows you to compare an object to a constructor, returning true or false based on whether or not that object was created with the constructor. Here's an example:</p>
<pre><code class="` language-`">let Bird = function(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

let crow = new Bird("Alexis", "black");

crow instanceof Bird; // =&gt; true
</code></pre>
<p>`
If an object is created without using a constructor, instanceof will verify that it is not an instance of that constructor:</p>
<pre><code class="` language-`">let canary = {
  name: "Mildred",
  color: "Yellow",
  numLegs: 2
};

canary instanceof Bird; // =&gt; false
</code></pre>
<p>`</p>
<hr />
<h2>Understand Own Properties</h2>
<p>In the following example, the Bird constructor defines two properties: name and numLegs:</p>
<pre><code class="` language-`">function Bird(name) {
  this.name = name;
  this.numLegs = 2;
}

let duck = new Bird("Donald");
let canary = new Bird("Tweety");
</code></pre>
<p>`
name and numLegs are called own properties, because they are defined directly on the instance object. That means that duck and canary each has its own separate copy of these properties.</p>
<p>In fact every instance of Bird will have its own copy of these properties.</p>
<p>The following code adds all of the own properties of duck to the array ownProps:</p>
<pre><code class="` language-`">let ownProps = [];

for (let property in duck) {
  if(duck.hasOwnProperty(property)) {
    ownProps.push(property);
  }
}

console.log(ownProps); // prints [ "name", "numLegs" ]
</code></pre>
<h2>`</h2>
<h2>Use Prototype Properties to Reduce Duplicate Code</h2>
<p>Since numLegs will probably have the same value for all instances of Bird, you essentially have a duplicated variable numLegs inside each Bird instance.</p>
<p>This may not be an issue when there are only two instances, but imagine if there are millions of instances. That would be a lot of duplicated variables.</p>
<p>A better way is to use Bird’s prototype. The prototype is an object that is shared among ALL instances of Bird. Here's how to add numLegs to the Bird prototype:</p>
<pre><code class="` language-`">Bird.prototype.numLegs = 2;
</code></pre>
<p>`
Now all instances of Bird have the numLegs property.</p>
<pre><code class="` language-`">console.log(duck.numLegs); // prints 2
console.log(canary.numLegs); // prints 2
</code></pre>
<p>`
Since all instances automatically have the properties on the prototype, think of a prototype as a "recipe" for creating objects.</p>
<p>Note that the prototype for duck and canary is part of the Bird constructor as Bird.prototype. Nearly every object in JavaScript has a prototype property which is part of the constructor function that created it.</p>
</body>
</html>